var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/constants.ts
var WORKFLOW_ID_HEADER = "Upstash-Workflow-RunId";
var WORKFLOW_INIT_HEADER = "Upstash-Workflow-Init";
var WORKFLOW_URL_HEADER = "Upstash-Workflow-Url";
var WORKFLOW_FAILURE_HEADER = "Upstash-Workflow-Is-Failure";
var WORKFLOW_FEATURE_HEADER = "Upstash-Feature-Set";
var WORKFLOW_INVOKE_COUNT_HEADER = "Upstash-Workflow-Invoke-Count";
var WORKFLOW_LABEL_HEADER = "Upstash-Label";
var WORKFLOW_PROTOCOL_VERSION = "1";
var WORKFLOW_PROTOCOL_VERSION_HEADER = "Upstash-Workflow-Sdk-Version";
var DEFAULT_CONTENT_TYPE = "application/json";
var NO_CONCURRENCY = 1;
var DEFAULT_RETRIES = 3;
var VERSION = "v0.2.20";
var SDK_TELEMETRY = `@upstash/workflow@${VERSION}`;
var TELEMETRY_HEADER_SDK = "Upstash-Telemetry-Sdk";
var TELEMETRY_HEADER_FRAMEWORK = "Upstash-Telemetry-Framework";
var TELEMETRY_HEADER_RUNTIME = "Upstash-Telemetry-Runtime";
var TELEMETRY_HEADER_AGENT = "Upstash-Telemetry-Agent";

// src/error.ts
import { QstashError } from "@upstash/qstash";
var WorkflowError = class extends QstashError {
  constructor(message) {
    super(message);
    this.name = "WorkflowError";
  }
};
var WorkflowAbort = class extends Error {
  stepInfo;
  stepName;
  /**
   * whether workflow is to be canceled on abort
   */
  cancelWorkflow;
  /**
   *
   * @param stepName name of the aborting step
   * @param stepInfo step information
   * @param cancelWorkflow
   */
  constructor(stepName, stepInfo, cancelWorkflow = false) {
    super(
      `This is an Upstash Workflow error thrown after a step executes. It is expected to be raised. Make sure that you await for each step. Also, if you are using try/catch blocks, you should not wrap context.run/sleep/sleepUntil/call methods with try/catch. Aborting workflow after executing step '${stepName}'.`
    );
    this.name = "WorkflowAbort";
    this.stepName = stepName;
    this.stepInfo = stepInfo;
    this.cancelWorkflow = cancelWorkflow;
  }
};
var WorkflowNonRetryableError = class extends WorkflowAbort {
  /**
   * @param message error message to be displayed
   */
  constructor(message) {
    super("fail", void 0, false);
    this.name = "WorkflowNonRetryableError";
    if (message) this.message = message;
  }
};
var formatWorkflowError = (error) => {
  return error instanceof Error ? {
    error: error.name,
    message: error.message,
    stack: error.stack
  } : {
    error: "Error",
    message: `An error occured while executing workflow: '${typeof error === "string" ? error : JSON.stringify(error)}'`
  };
};

// src/types.ts
var StepTypes = [
  "Initial",
  "Run",
  "SleepFor",
  "SleepUntil",
  "Call",
  "Wait",
  "Notify",
  "Invoke"
];

// src/agents/adapters.ts
import { tool } from "ai";

// src/agents/constants.ts
var AGENT_NAME_HEADER = "upstash-agent-name";
var MANAGER_AGENT_PROMPT = `You are an agent orchestrating other AI Agents.

These other agents have tools available to them.

Given a prompt, utilize these agents to address requests.

Don't always call all the agents provided to you at the same time. You can call one and use it's response to call another.

Avoid calling the same agent twice in one turn. Instead, prefer to call it once but provide everything
you need from that agent.
`;

// src/agents/adapters.ts
var fetchWithContextCall = async (context, agentCallParams, ...params) => {
  const [input, init] = params;
  try {
    const headers = init?.headers ? Object.fromEntries(new Headers(init.headers).entries()) : {};
    const body = init?.body ? JSON.parse(init.body) : void 0;
    const agentName = headers[AGENT_NAME_HEADER];
    const stepName = agentName ? `Call Agent ${agentName}` : "Call Agent";
    const responseInfo = await context.call(stepName, {
      url: input.toString(),
      method: init?.method,
      headers,
      body,
      timeout: agentCallParams?.timeout,
      retries: agentCallParams?.retries,
      retryDelay: agentCallParams?.retryDelay,
      flowControl: agentCallParams?.flowControl
    });
    const responseHeaders = new Headers(
      Object.entries(responseInfo.header).reduce(
        (acc, [key, values]) => {
          acc[key] = values.join(", ");
          return acc;
        },
        {}
      )
    );
    return new Response(JSON.stringify(responseInfo.body), {
      status: responseInfo.status,
      headers: responseHeaders
    });
  } catch (error) {
    if (error instanceof Error && error.name === "WorkflowAbort") {
      throw error;
    } else {
      console.error("Error in fetch implementation:", error);
      throw error;
    }
  }
};
var createWorkflowModel = ({
  context,
  provider,
  providerParams,
  agentCallParams
}) => {
  return provider({
    fetch: (...params) => fetchWithContextCall(context, agentCallParams, ...params),
    ...providerParams
  });
};
var wrapTools = ({
  context,
  tools
}) => {
  return Object.fromEntries(
    Object.entries(tools).map((toolInfo) => {
      const [toolName, tool3] = toolInfo;
      const executeAsStep = "executeAsStep" in tool3 ? tool3.executeAsStep : true;
      const aiSDKTool = convertToAISDKTool(tool3);
      const execute = aiSDKTool.execute;
      if (execute && executeAsStep) {
        const wrappedExecute = (...params) => {
          return context.run(`Run tool ${toolName}`, () => execute(...params));
        };
        aiSDKTool.execute = wrappedExecute;
      }
      return [toolName, aiSDKTool];
    })
  );
};
var convertToAISDKTool = (tool3) => {
  const isLangchainTool = "invoke" in tool3;
  return isLangchainTool ? convertLangchainTool(tool3) : tool3;
};
var convertLangchainTool = (langchainTool) => {
  return tool({
    description: langchainTool.description,
    parameters: langchainTool.schema,
    execute: async (...param) => langchainTool.invoke(...param)
  });
};
var WorkflowTool = class {
  /**
   * description of the tool
   */
  description;
  /**
   * schema of the tool
   */
  schema;
  /**
   * function to invoke the tool
   */
  invoke;
  /**
   * whether the invoke method of the tool is to be wrapped with `context.run`
   */
  executeAsStep;
  /**
   *
   * @param description description of the tool
   * @param schema schema of the tool
   * @param invoke function to invoke the tool
   * @param executeAsStep whether the invoke method of the tool is to be wrapped with `context.run`
   */
  constructor(params) {
    this.description = params.description;
    this.schema = params.schema;
    this.invoke = params.invoke;
    this.executeAsStep = params.executeAsStep ?? true;
  }
};

// src/serve/serve-many.ts
var getWorkflowId = (url) => {
  const components = url.split("/");
  const lastComponent = components[components.length - 1];
  return lastComponent.split("?")[0];
};
var serveManyBase = ({
  workflows,
  getUrl,
  serveMethod,
  options
}) => {
  const workflowIds = [];
  const workflowMap = Object.fromEntries(
    Object.entries(workflows).map((workflow) => {
      const workflowId = workflow[0];
      if (workflowIds.includes(workflowId)) {
        throw new WorkflowError(
          `Duplicate workflow name found: '${workflowId}'. Please set different workflow names in serveMany.`
        );
      }
      if (workflowId.includes("/")) {
        throw new WorkflowError(
          `Invalid workflow name found: '${workflowId}'. Workflow name cannot contain '/'.`
        );
      }
      workflowIds.push(workflowId);
      workflow[1].workflowId = workflowId;
      workflow[1].options = {
        ...options,
        ...workflow[1].options
      };
      const params = [workflow[1].routeFunction, workflow[1].options];
      const handler = serveMethod(...params);
      return [workflowId, handler];
    })
  );
  return {
    handler: async (...params) => {
      const url = getUrl(...params);
      const pickedWorkflowId = getWorkflowId(url);
      if (!pickedWorkflowId) {
        return new Response(
          `Unexpected request in serveMany. workflowId not set. Please update the URL of your request.`,
          {
            status: 404,
            headers: {
              [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
            }
          }
        );
      }
      const workflow = workflowMap[pickedWorkflowId];
      if (!workflow) {
        return new Response(
          `No workflows in serveMany found for '${pickedWorkflowId}'. Please update the URL of your request.`,
          {
            status: 404,
            headers: {
              [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
            }
          }
        );
      }
      return await workflow(...params);
    }
  };
};
var getNewUrlFromWorkflowId = (url, workflowId) => {
  if (!workflowId) {
    throw new WorkflowError("You can only call workflow which has a workflowId");
  }
  return url.replace(/[^/]+$/, workflowId);
};

// src/context/auto-executor.ts
import { QstashError as QstashError5 } from "@upstash/qstash";

// src/qstash/headers.ts
import { QstashError as QstashError4 } from "@upstash/qstash";

// src/client/utils.ts
import { QstashError as QstashError2 } from "@upstash/qstash";
var makeNotifyRequest = async (requester, eventId, eventData) => {
  const result = await requester.request({
    path: ["v2", "notify", eventId],
    method: "POST",
    body: typeof eventData === "string" ? eventData : JSON.stringify(eventData)
  });
  return result;
};
var makeGetWaitersRequest = async (requester, eventId) => {
  const result = await requester.request({
    path: ["v2", "waiters", eventId],
    method: "GET"
  });
  return result;
};
var makeCancelRequest = async (requester, workflowRunId) => {
  await requester.request({
    path: ["v2", "workflows", "runs", `${workflowRunId}?cancel=true`],
    method: "DELETE",
    parseResponseAsJson: false
  });
  return true;
};
var getSteps = async (requester, workflowRunId, messageId, debug) => {
  try {
    const steps = await requester.request({
      path: ["v2", "workflows", "runs", workflowRunId],
      parseResponseAsJson: true
    });
    if (!messageId) {
      await debug?.log("INFO", "ENDPOINT_START", {
        message: `Pulled ${steps.length} steps from QStashand returned them without filtering with messageId.`
      });
      return { steps, workflowRunEnded: false };
    } else {
      const index = steps.findIndex((item) => item.messageId === messageId);
      if (index === -1) {
        return { steps: [], workflowRunEnded: false };
      }
      const filteredSteps = steps.slice(0, index + 1);
      await debug?.log("INFO", "ENDPOINT_START", {
        message: `Pulled ${steps.length} steps from QStash and filtered them to ${filteredSteps.length} using messageId.`
      });
      return { steps: filteredSteps, workflowRunEnded: false };
    }
  } catch (error) {
    if (error instanceof QstashError2 && error.status === 404) {
      await debug?.log("WARN", "ENDPOINT_START", {
        message: "Couldn't fetch workflow run steps. This can happen if the workflow run succesfully ends before some callback is executed.",
        error
      });
      return { steps: void 0, workflowRunEnded: true };
    } else {
      throw error;
    }
  }
};

// src/utils.ts
var NANOID_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
var NANOID_LENGTH = 21;
function getRandomInt() {
  return Math.floor(Math.random() * NANOID_CHARS.length);
}
function nanoid() {
  return Array.from({ length: NANOID_LENGTH }).map(() => NANOID_CHARS[getRandomInt()]).join("");
}
function getWorkflowRunId(id) {
  return `wfr_${id ?? nanoid()}`;
}
function decodeBase64(base64) {
  const binString = atob(base64);
  try {
    const intArray = Uint8Array.from(binString, (m) => m.codePointAt(0));
    return new TextDecoder().decode(intArray);
  } catch (error) {
    console.warn(
      `Upstash Qstash: Failed while decoding base64 "${base64}". Decoding with atob and returning it instead. ${error}`
    );
    return binString;
  }
}

// node_modules/neverthrow/dist/index.es.js
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var ResultAsync = class _ResultAsync {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise) {
    const newPromise = promise.then((value) => new Ok(value));
    return new _ResultAsync(newPromise);
  }
  static fromPromise(promise, errorFn) {
    const newPromise = promise.then((value) => new Ok(value)).catch((e) => new Err(errorFn(e)));
    return new _ResultAsync(newPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromThrowable(fn, errorFn) {
    return (...args) => {
      return new _ResultAsync((() => __awaiter(this, void 0, void 0, function* () {
        try {
          return new Ok(yield fn(...args));
        } catch (error) {
          return new Err(errorFn ? errorFn(error) : error);
        }
      }))());
    };
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f(res.value));
    })));
  }
  andThrough(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newRes = yield f(res.value);
      if (newRes.isErr()) {
        return new Err(newRes.error);
      }
      return new Ok(res.value);
    })));
  }
  andTee(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      try {
        yield f(res.value);
      } catch (e) {
      }
      return new Ok(res.value);
    })));
  }
  mapErr(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return new _ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f(res.value);
      return newValue instanceof _ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t) {
    return this._promise.then((res) => res.unwrapOr(t));
  }
  /**
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
};
var errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var fromAsyncThrowable = ResultAsync.fromThrowable;
var combineResultList = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr()) {
      acc = err(result.error);
      break;
    } else {
      acc.map((list) => list.push(result.value));
    }
  }
  return acc;
};
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr() && acc.isErr()) {
      acc.error.push(result.error);
    } else if (result.isErr() && acc.isOk()) {
      acc = err([result.error]);
    } else if (result.isOk() && acc.isOk()) {
      acc.value.push(result.value);
    }
  }
  return acc;
};
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args) => {
      try {
        const result = fn(...args);
        return ok(result);
      } catch (e) {
        return err(errorFn ? errorFn(e) : e);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
var ok = (value) => new Ok(value);
function err(err2) {
  return new Err(err2);
}
var Ok = class {
  constructor(value) {
    this.value = value;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f) {
    return ok(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return f(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThrough(f) {
    return f(this.value).map((_value) => this.value);
  }
  andTee(f) {
    try {
      f(this.value);
    } catch (e) {
    }
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f) {
    return f(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  asyncAndThrough(f) {
    return f(this.value).map(() => this.value);
  }
  asyncMap(f) {
    return ResultAsync.fromSafePromise(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value = this.value;
    return function* () {
      return value;
    }();
  }
  _unsafeUnwrap(_) {
    return this.value;
  }
  _unsafeUnwrapErr(config) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config);
  }
};
var Err = class {
  constructor(error) {
    this.error = error;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f) {
    return err(f(this.error));
  }
  andThrough(_f) {
    return err(this.error);
  }
  andTee(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return f(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  asyncAndThrough(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v) {
    return v;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error = this.error;
    return function* () {
      yield err(error);
      throw new Error("Do not use this generator out of `safeTry`");
    }();
  }
  _unsafeUnwrap(config) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config);
  }
  _unsafeUnwrapErr(_) {
    return this.error;
  }
};
var fromThrowable = Result.fromThrowable;

// src/workflow-requests.ts
import { QstashError as QstashError3 } from "@upstash/qstash";
var triggerFirstInvocation = async (params) => {
  const firstInvocationParams = Array.isArray(params) ? params : [params];
  const workflowContextClient = firstInvocationParams[0].workflowContext.qstashClient;
  const invocationBatch = firstInvocationParams.map(
    ({ workflowContext, useJSONContent, telemetry, invokeCount, delay, notBefore }) => {
      const { headers } = getHeaders({
        initHeaderValue: "true",
        workflowConfig: {
          workflowRunId: workflowContext.workflowRunId,
          workflowUrl: workflowContext.url,
          failureUrl: workflowContext.failureUrl,
          retries: workflowContext.retries,
          retryDelay: workflowContext.retryDelay,
          telemetry,
          flowControl: workflowContext.flowControl,
          useJSONContent: useJSONContent ?? false
        },
        invokeCount: invokeCount ?? 0,
        userHeaders: workflowContext.headers
      });
      if (workflowContext.headers.get("content-type")) {
        headers["content-type"] = workflowContext.headers.get("content-type");
      }
      if (useJSONContent) {
        headers["content-type"] = "application/json";
      }
      if (workflowContext.label) {
        headers[WORKFLOW_LABEL_HEADER] = workflowContext.label;
      }
      const body = typeof workflowContext.requestPayload === "string" ? workflowContext.requestPayload : JSON.stringify(workflowContext.requestPayload);
      return {
        headers,
        method: "POST",
        body,
        url: workflowContext.url,
        delay,
        notBefore
      };
    }
  );
  try {
    const results = await workflowContextClient.batch(invocationBatch);
    const invocationStatuses = [];
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const invocationParams = firstInvocationParams[i];
      if (result.deduplicated) {
        await invocationParams.debug?.log("WARN", "SUBMIT_FIRST_INVOCATION", {
          message: `Workflow run ${invocationParams.workflowContext.workflowRunId} already exists. A new one isn't created.`,
          headers: invocationBatch[i].headers,
          requestPayload: invocationParams.workflowContext.requestPayload,
          url: invocationParams.workflowContext.url,
          messageId: result.messageId
        });
        invocationStatuses.push("workflow-run-already-exists");
      } else {
        await invocationParams.debug?.log("SUBMIT", "SUBMIT_FIRST_INVOCATION", {
          headers: invocationBatch[i].headers,
          requestPayload: invocationParams.workflowContext.requestPayload,
          url: invocationParams.workflowContext.url,
          messageId: result.messageId
        });
        invocationStatuses.push("success");
      }
    }
    const hasAnyDeduplicated = invocationStatuses.some(
      (status) => status === "workflow-run-already-exists"
    );
    if (hasAnyDeduplicated) {
      return ok("workflow-run-already-exists");
    } else {
      return ok("success");
    }
  } catch (error) {
    const error_ = error;
    return err(error_);
  }
};
var triggerRouteFunction = async ({
  onCleanup,
  onStep,
  onCancel,
  debug
}) => {
  try {
    const result = await onStep();
    await onCleanup(result);
    return ok("workflow-finished");
  } catch (error) {
    const error_ = error;
    if (error instanceof QstashError3 && error.status === 400) {
      await debug?.log("WARN", "RESPONSE_WORKFLOW", {
        message: `tried to append to a cancelled workflow. exiting without publishing.`,
        name: error.name,
        errorMessage: error.message
      });
      return ok("workflow-was-finished");
    } else if (!(error_ instanceof WorkflowAbort)) {
      return err(error_);
    } else if (error_ instanceof WorkflowNonRetryableError) {
      return ok(error_);
    } else if (error_.cancelWorkflow) {
      await onCancel();
      return ok("workflow-finished");
    } else {
      return ok("step-finished");
    }
  }
};
var triggerWorkflowDelete = async (workflowContext, result, debug, cancel = false) => {
  await debug?.log("SUBMIT", "SUBMIT_CLEANUP", {
    deletedWorkflowRunId: workflowContext.workflowRunId
  });
  await workflowContext.qstashClient.http.request({
    path: ["v2", "workflows", "runs", `${workflowContext.workflowRunId}?cancel=${cancel}`],
    method: "DELETE",
    parseResponseAsJson: false,
    body: JSON.stringify(result)
  });
  await debug?.log(
    "SUBMIT",
    "SUBMIT_CLEANUP",
    `workflow run ${workflowContext.workflowRunId} deleted.`
  );
};
var recreateUserHeaders = (headers) => {
  const filteredHeaders = new Headers();
  const pairs = headers.entries();
  for (const [header, value] of pairs) {
    const headerLowerCase = header.toLowerCase();
    const isUserHeader = !headerLowerCase.startsWith("upstash-workflow-") && // https://vercel.com/docs/edge-network/headers/request-headers#x-vercel-id
    !headerLowerCase.startsWith("x-vercel-") && !headerLowerCase.startsWith("x-forwarded-") && // https://blog.cloudflare.com/preventing-request-loops-using-cdn-loop/
    headerLowerCase !== "cf-connecting-ip" && headerLowerCase !== "cdn-loop" && headerLowerCase !== "cf-ew-via" && headerLowerCase !== "cf-ray" && // For Render https://render.com
    headerLowerCase !== "render-proxy-ttl" || headerLowerCase === WORKFLOW_LABEL_HEADER.toLocaleLowerCase();
    if (isUserHeader) {
      filteredHeaders.append(header, value);
    }
  }
  return filteredHeaders;
};
var handleThirdPartyCallResult = async ({
  request,
  requestPayload,
  client,
  workflowUrl,
  failureUrl,
  retries,
  retryDelay,
  telemetry,
  flowControl,
  debug
}) => {
  try {
    if (request.headers.get("Upstash-Workflow-Callback")) {
      let callbackPayload;
      if (requestPayload) {
        callbackPayload = requestPayload;
      } else {
        const workflowRunId2 = request.headers.get("upstash-workflow-runid");
        const messageId = request.headers.get("upstash-message-id");
        if (!workflowRunId2)
          throw new WorkflowError("workflow run id missing in context.call lazy fetch.");
        if (!messageId) throw new WorkflowError("message id missing in context.call lazy fetch.");
        const { steps, workflowRunEnded } = await getSteps(
          client.http,
          workflowRunId2,
          messageId,
          debug
        );
        if (workflowRunEnded) {
          return ok("workflow-ended");
        }
        const failingStep = steps.find((step) => step.messageId === messageId);
        if (!failingStep)
          throw new WorkflowError(
            "Failed to submit the context.call. " + (steps.length === 0 ? "No steps found." : `No step was found with matching messageId ${messageId} out of ${steps.length} steps.`)
          );
        callbackPayload = atob(failingStep.body);
      }
      const callbackMessage = JSON.parse(callbackPayload);
      if (!(callbackMessage.status >= 200 && callbackMessage.status < 300) && callbackMessage.maxRetries && callbackMessage.retried !== callbackMessage.maxRetries) {
        await debug?.log("WARN", "SUBMIT_THIRD_PARTY_RESULT", {
          status: callbackMessage.status,
          body: atob(callbackMessage.body ?? "")
        });
        console.warn(
          `Workflow Warning: "context.call" failed with status ${callbackMessage.status} and will retry (retried ${callbackMessage.retried ?? 0} out of ${callbackMessage.maxRetries} times). Error Message:
${atob(callbackMessage.body ?? "")}`
        );
        return ok("call-will-retry");
      }
      const workflowRunId = request.headers.get(WORKFLOW_ID_HEADER);
      const stepIdString = request.headers.get("Upstash-Workflow-StepId");
      const stepName = request.headers.get("Upstash-Workflow-StepName");
      const stepType = request.headers.get("Upstash-Workflow-StepType");
      const concurrentString = request.headers.get("Upstash-Workflow-Concurrent");
      const contentType = request.headers.get("Upstash-Workflow-ContentType");
      const invokeCount = request.headers.get(WORKFLOW_INVOKE_COUNT_HEADER);
      if (!(workflowRunId && stepIdString && stepName && StepTypes.includes(stepType) && concurrentString && contentType)) {
        throw new Error(
          `Missing info in callback message source header: ${JSON.stringify({
            workflowRunId,
            stepIdString,
            stepName,
            stepType,
            concurrentString,
            contentType
          })}`
        );
      }
      const userHeaders = recreateUserHeaders(request.headers);
      const { headers: requestHeaders } = getHeaders({
        initHeaderValue: "false",
        workflowConfig: {
          workflowRunId,
          workflowUrl,
          failureUrl,
          retries,
          retryDelay,
          telemetry,
          flowControl
        },
        userHeaders,
        invokeCount: Number(invokeCount)
      });
      const callResponse = {
        status: callbackMessage.status,
        body: atob(callbackMessage.body ?? ""),
        header: callbackMessage.header
      };
      const callResultStep = {
        stepId: Number(stepIdString),
        stepName,
        stepType,
        out: JSON.stringify(callResponse),
        concurrent: Number(concurrentString)
      };
      await debug?.log("SUBMIT", "SUBMIT_THIRD_PARTY_RESULT", {
        step: callResultStep,
        headers: requestHeaders,
        url: workflowUrl
      });
      const result = await client.publishJSON({
        headers: requestHeaders,
        method: "POST",
        body: callResultStep,
        url: workflowUrl
      });
      await debug?.log("SUBMIT", "SUBMIT_THIRD_PARTY_RESULT", {
        messageId: result.messageId
      });
      return ok("is-call-return");
    } else {
      return ok("continue-workflow");
    }
  } catch (error) {
    const isCallReturn = request.headers.get("Upstash-Workflow-Callback");
    return err(
      new WorkflowError(`Error when handling call return (isCallReturn=${isCallReturn}): ${error}`)
    );
  }
};
var getTelemetryHeaders = (telemetry) => {
  return {
    [TELEMETRY_HEADER_SDK]: telemetry.sdk,
    [TELEMETRY_HEADER_FRAMEWORK]: telemetry.framework ?? "unknown",
    [TELEMETRY_HEADER_RUNTIME]: telemetry.runtime ?? "unknown"
  };
};
var verifyRequest = async (body, signature, verifier) => {
  if (!verifier) {
    return;
  }
  try {
    if (!signature) {
      throw new Error("`Upstash-Signature` header is not passed.");
    }
    const isValid = await verifier.verify({
      body,
      signature
    });
    if (!isValid) {
      throw new Error("Signature in `Upstash-Signature` header is not valid");
    }
  } catch (error) {
    throw new WorkflowError(
      `Failed to verify that the Workflow request comes from QStash: ${error}

If signature is missing, trigger the workflow endpoint by publishing your request to QStash instead of calling it directly.

If you want to disable QStash Verification, you should clear env variables QSTASH_CURRENT_SIGNING_KEY and QSTASH_NEXT_SIGNING_KEY`
    );
  }
};

// src/context/steps.ts
var BaseLazyStep = class _BaseLazyStep {
  stepName;
  constructor(stepName) {
    if (!stepName) {
      throw new WorkflowError(
        "A workflow step name cannot be undefined or an empty string. Please provide a name for your workflow step."
      );
    }
    if (typeof stepName !== "string") {
      console.warn(
        "Workflow Warning: A workflow step name must be a string. In a future release, this will throw an error."
      );
    }
    this.stepName = stepName;
  }
  /**
   * parse the out field of a step result.
   *
   * will be called when returning the steps to the context from auto executor
   *
   * @param out field of the step
   * @returns parsed out field
   */
  parseOut(out) {
    if (out === void 0) {
      if (this.allowUndefinedOut) {
        return void 0;
      } else {
        throw new WorkflowError(
          `Error while parsing output of ${this.stepType} step. Expected a string, but got: undefined`
        );
      }
    }
    if (typeof out === "object") {
      if (this.stepType !== "Wait") {
        console.warn(
          `Error while parsing ${this.stepType} step output. Expected a string, but got object. Please reach out to Upstash Support.`
        );
        return out;
      }
      return {
        ...out,
        eventData: _BaseLazyStep.tryParsing(out.eventData)
      };
    }
    if (typeof out !== "string") {
      throw new WorkflowError(
        `Error while parsing output of ${this.stepType} step. Expected a string or undefined, but got: ${typeof out}`
      );
    }
    return this.safeParseOut(out);
  }
  safeParseOut(out) {
    return _BaseLazyStep.tryParsing(out);
  }
  static tryParsing(stepOut) {
    try {
      return JSON.parse(stepOut);
    } catch {
      return stepOut;
    }
  }
  getBody({ step }) {
    step.out = JSON.stringify(step.out);
    return JSON.stringify(step);
  }
  getHeaders({ context, telemetry, invokeCount, step }) {
    return getHeaders({
      initHeaderValue: "false",
      workflowConfig: {
        workflowRunId: context.workflowRunId,
        workflowUrl: context.url,
        failureUrl: context.failureUrl,
        retries: DEFAULT_RETRIES === context.retries ? void 0 : context.retries,
        retryDelay: context.retryDelay,
        useJSONContent: false,
        telemetry,
        flowControl: context.flowControl
      },
      userHeaders: context.headers,
      invokeCount,
      stepInfo: {
        step,
        lazyStep: this
      }
    });
  }
  async submitStep({ context, body, headers }) {
    return await context.qstashClient.batch([
      {
        body,
        headers,
        method: "POST",
        retries: DEFAULT_RETRIES === context.retries ? void 0 : context.retries,
        retryDelay: context.retryDelay,
        flowControl: context.flowControl,
        url: context.url
      }
    ]);
  }
};
var LazyFunctionStep = class extends BaseLazyStep {
  stepFunction;
  stepType = "Run";
  allowUndefinedOut = true;
  constructor(stepName, stepFunction) {
    super(stepName);
    this.stepFunction = stepFunction;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    let result = this.stepFunction();
    if (result instanceof Promise) {
      result = await result;
    }
    return {
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      out: result,
      concurrent
    };
  }
};
var LazySleepStep = class extends BaseLazyStep {
  sleep;
  stepType = "SleepFor";
  allowUndefinedOut = true;
  constructor(stepName, sleep) {
    super(stepName);
    this.sleep = sleep;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepFor: this.sleep,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepFor: this.sleep,
      concurrent
    });
  }
  async submitStep({ context, body, headers, isParallel }) {
    return await context.qstashClient.batch([
      {
        body,
        headers,
        method: "POST",
        url: context.url,
        retries: DEFAULT_RETRIES === context.retries ? void 0 : context.retries,
        retryDelay: context.retryDelay,
        flowControl: context.flowControl,
        delay: isParallel ? void 0 : this.sleep
      }
    ]);
  }
};
var LazySleepUntilStep = class extends BaseLazyStep {
  sleepUntil;
  stepType = "SleepUntil";
  allowUndefinedOut = true;
  constructor(stepName, sleepUntil) {
    super(stepName);
    this.sleepUntil = sleepUntil;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepUntil: this.sleepUntil,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepUntil: this.sleepUntil,
      concurrent
    });
  }
  safeParseOut() {
    return void 0;
  }
  async submitStep({ context, body, headers, isParallel }) {
    return await context.qstashClient.batch([
      {
        body,
        headers,
        method: "POST",
        url: context.url,
        retries: DEFAULT_RETRIES === context.retries ? void 0 : context.retries,
        retryDelay: context.retryDelay,
        flowControl: context.flowControl,
        notBefore: isParallel ? void 0 : this.sleepUntil
      }
    ]);
  }
};
var LazyCallStep = class _LazyCallStep extends BaseLazyStep {
  url;
  method;
  body;
  headers;
  retries;
  retryDelay;
  timeout;
  flowControl;
  stringifyBody;
  stepType = "Call";
  allowUndefinedOut = false;
  constructor(stepName, url, method, body, headers, retries, retryDelay, timeout, flowControl, stringifyBody) {
    super(stepName);
    this.url = url;
    this.method = method;
    this.body = body;
    this.headers = headers;
    this.retries = retries;
    this.retryDelay = retryDelay;
    this.timeout = timeout;
    this.flowControl = flowControl;
    this.stringifyBody = stringifyBody;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      callUrl: this.url,
      callMethod: this.method,
      callBody: this.body,
      callHeaders: this.headers
    });
  }
  safeParseOut(out) {
    const { header, status, body } = JSON.parse(out);
    const responseHeaders = new Headers(header);
    if (_LazyCallStep.isText(responseHeaders.get("content-type"))) {
      const bytes = new Uint8Array(out.length);
      for (let i = 0; i < out.length; i++) {
        bytes[i] = out.charCodeAt(i);
      }
      const processedResult = new TextDecoder().decode(bytes);
      const newBody = JSON.parse(processedResult).body;
      return {
        status,
        header,
        body: BaseLazyStep.tryParsing(newBody)
      };
    } else {
      return { header, status, body };
    }
  }
  static applicationContentTypes = [
    "application/json",
    "application/xml",
    "application/javascript",
    "application/x-www-form-urlencoded",
    "application/xhtml+xml",
    "application/ld+json",
    "application/rss+xml",
    "application/atom+xml"
  ];
  static isText = (contentTypeHeader) => {
    if (!contentTypeHeader) {
      return false;
    }
    if (_LazyCallStep.applicationContentTypes.some((type) => contentTypeHeader.includes(type))) {
      return true;
    }
    if (contentTypeHeader.startsWith("text/")) {
      return true;
    }
    return false;
  };
  getBody({ step }) {
    if (!step.callUrl) {
      throw new WorkflowError("Incompatible step received in LazyCallStep.getBody");
    }
    return JSON.stringify(step.callBody);
  }
  getHeaders({ context, telemetry, invokeCount, step }) {
    const { headers, contentType } = super.getHeaders({ context, telemetry, invokeCount, step });
    headers["Upstash-Retries"] = this.retries.toString();
    if (this.retryDelay) {
      headers["Upstash-Retry-Delay"] = this.retryDelay;
    }
    headers[WORKFLOW_FEATURE_HEADER] = "WF_NoDelete,InitialBody";
    if (this.flowControl) {
      const { flowControlKey, flowControlValue } = prepareFlowControl(this.flowControl);
      headers["Upstash-Flow-Control-Key"] = flowControlKey;
      headers["Upstash-Flow-Control-Value"] = flowControlValue;
    }
    if (this.timeout) {
      headers["Upstash-Timeout"] = this.timeout.toString();
    }
    const forwardedHeaders = Object.fromEntries(
      Object.entries(this.headers).map(([header, value]) => [`Upstash-Forward-${header}`, value])
    );
    return {
      headers: {
        ...headers,
        ...forwardedHeaders,
        "Upstash-Callback": context.url,
        "Upstash-Callback-Workflow-RunId": context.workflowRunId,
        "Upstash-Callback-Workflow-CallType": "fromCallback",
        "Upstash-Callback-Workflow-Init": "false",
        "Upstash-Callback-Workflow-Url": context.url,
        "Upstash-Callback-Feature-Set": "LazyFetch,InitialBody,WF_DetectTrigger",
        "Upstash-Callback-Forward-Upstash-Workflow-Callback": "true",
        "Upstash-Callback-Forward-Upstash-Workflow-StepId": step.stepId.toString(),
        "Upstash-Callback-Forward-Upstash-Workflow-StepName": this.stepName,
        "Upstash-Callback-Forward-Upstash-Workflow-StepType": this.stepType,
        "Upstash-Callback-Forward-Upstash-Workflow-Concurrent": step.concurrent.toString(),
        "Upstash-Callback-Forward-Upstash-Workflow-ContentType": contentType,
        "Upstash-Workflow-CallType": "toCallback"
      },
      contentType
    };
  }
  async submitStep({ context, headers }) {
    let callBody;
    if (this.stringifyBody) {
      callBody = JSON.stringify(this.body);
    } else {
      if (typeof this.body === "string") {
        callBody = this.body;
      } else {
        throw new WorkflowError(
          "When stringifyBody is false, body must be a string. Please check the body type of your call step."
        );
      }
    }
    return await context.qstashClient.batch([
      {
        headers,
        body: callBody,
        method: this.method,
        url: this.url,
        retries: DEFAULT_RETRIES === this.retries ? void 0 : this.retries,
        retryDelay: this.retryDelay,
        flowControl: this.flowControl
      }
    ]);
  }
};
var LazyWaitForEventStep = class extends BaseLazyStep {
  eventId;
  timeout;
  stepType = "Wait";
  allowUndefinedOut = false;
  constructor(stepName, eventId, timeout) {
    super(stepName);
    this.eventId = eventId;
    this.timeout = timeout;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      waitEventId: this.eventId,
      timeout: this.timeout,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      waitEventId: this.eventId,
      timeout: this.timeout,
      concurrent
    });
  }
  safeParseOut(out) {
    const result = JSON.parse(out);
    return {
      ...result,
      eventData: BaseLazyStep.tryParsing(result.eventData)
    };
  }
  getHeaders({ context, telemetry, invokeCount, step }) {
    const headers = super.getHeaders({ context, telemetry, invokeCount, step });
    headers.headers["Upstash-Workflow-CallType"] = "step";
    return headers;
  }
  getBody({ context, step, headers, telemetry }) {
    if (!step.waitEventId) {
      throw new WorkflowError("Incompatible step received in LazyWaitForEventStep.getBody");
    }
    const timeoutHeaders = {
      // to include user headers:
      ...Object.fromEntries(Object.entries(headers).map(([header, value]) => [header, [value]])),
      // to include telemetry headers:
      ...telemetry ? Object.fromEntries(
        Object.entries(getTelemetryHeaders(telemetry)).map(([header, value]) => [
          header,
          [value]
        ])
      ) : {},
      // note: using WORKFLOW_ID_HEADER doesn't work, because Runid -> RunId:
      "Upstash-Workflow-Runid": [context.workflowRunId],
      [WORKFLOW_INIT_HEADER]: ["false"],
      [WORKFLOW_URL_HEADER]: [context.url],
      "Upstash-Workflow-CallType": ["step"]
    };
    const waitBody = {
      url: context.url,
      timeout: step.timeout,
      timeoutBody: void 0,
      timeoutUrl: context.url,
      timeoutHeaders,
      step: {
        stepId: step.stepId,
        stepType: "Wait",
        stepName: step.stepName,
        concurrent: step.concurrent,
        targetStep: step.targetStep
      }
    };
    return JSON.stringify(waitBody);
  }
  async submitStep({ context, body, headers }) {
    const result = await context.qstashClient.http.request({
      path: ["v2", "wait", this.eventId],
      body,
      headers,
      method: "POST",
      parseResponseAsJson: false
    });
    return [result];
  }
};
var LazyNotifyStep = class extends LazyFunctionStep {
  stepType = "Notify";
  constructor(stepName, eventId, eventData, requester) {
    super(stepName, async () => {
      const notifyResponse = await makeNotifyRequest(requester, eventId, eventData);
      return {
        eventId,
        eventData,
        notifyResponse
      };
    });
  }
  safeParseOut(out) {
    const result = JSON.parse(out);
    return {
      ...result,
      eventData: BaseLazyStep.tryParsing(result.eventData)
    };
  }
};
var LazyInvokeStep = class extends BaseLazyStep {
  stepType = "Invoke";
  params;
  allowUndefinedOut = false;
  /**
   * workflow id of the invoked workflow
   */
  workflowId;
  constructor(stepName, {
    workflow,
    body,
    headers = {},
    workflowRunId,
    retries,
    retryDelay,
    flowControl,
    stringifyBody = true
  }) {
    super(stepName);
    this.params = {
      workflow,
      body,
      headers,
      workflowRunId: getWorkflowRunId(workflowRunId),
      retries,
      retryDelay,
      flowControl,
      stringifyBody
    };
    const { workflowId } = workflow;
    if (!workflowId) {
      throw new WorkflowError("You can only invoke workflow which has a workflowId");
    }
    this.workflowId = workflowId;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  /**
   * won't be used as it's the server who will add the result step
   * in Invoke step.
   */
  getResultStep(concurrent, stepId) {
    return Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent
    });
  }
  safeParseOut(out) {
    const result = JSON.parse(out);
    return {
      ...result,
      body: BaseLazyStep.tryParsing(result.body)
    };
  }
  getBody({ context, step, telemetry, invokeCount }) {
    const { headers: invokerHeaders } = getHeaders({
      initHeaderValue: "false",
      workflowConfig: {
        workflowRunId: context.workflowRunId,
        workflowUrl: context.url,
        failureUrl: context.failureUrl,
        retries: context.retries,
        retryDelay: context.retryDelay,
        telemetry,
        flowControl: context.flowControl,
        useJSONContent: false
      },
      userHeaders: context.headers,
      invokeCount
    });
    invokerHeaders["Upstash-Workflow-Runid"] = context.workflowRunId;
    let invokeBody;
    if (this.params.stringifyBody) {
      invokeBody = JSON.stringify(this.params.body);
    } else {
      if (typeof this.params.body === "string") {
        invokeBody = this.params.body;
      } else {
        throw new WorkflowError(
          "When stringifyBody is false, body must be a string. Please check the body type of your invoke step."
        );
      }
    }
    const request = {
      body: invokeBody,
      headers: Object.fromEntries(
        Object.entries(invokerHeaders).map((pairs) => [pairs[0], [pairs[1]]])
      ),
      workflowRunId: context.workflowRunId,
      workflowUrl: context.url,
      step
    };
    return JSON.stringify(request);
  }
  getHeaders({ context, telemetry, invokeCount }) {
    const {
      workflow,
      headers = {},
      workflowRunId = getWorkflowRunId(),
      retries,
      retryDelay,
      flowControl
    } = this.params;
    const newUrl = context.url.replace(/[^/]+$/, this.workflowId);
    const {
      retries: workflowRetries,
      retryDelay: workflowRetryDelay,
      failureFunction,
      failureUrl,
      useJSONContent,
      flowControl: workflowFlowControl
    } = workflow.options;
    const { headers: triggerHeaders, contentType } = getHeaders({
      initHeaderValue: "true",
      workflowConfig: {
        workflowRunId,
        workflowUrl: newUrl,
        retries: retries ?? workflowRetries,
        retryDelay: retryDelay ?? workflowRetryDelay,
        telemetry,
        failureUrl: failureFunction ? newUrl : failureUrl,
        flowControl: flowControl ?? workflowFlowControl,
        useJSONContent: useJSONContent ?? false
      },
      invokeCount: invokeCount + 1,
      userHeaders: new Headers(headers)
    });
    triggerHeaders["Upstash-Workflow-Invoke"] = "true";
    return { headers: triggerHeaders, contentType };
  }
  async submitStep({ context, body, headers }) {
    const newUrl = context.url.replace(/[^/]+$/, this.workflowId);
    const result = await context.qstashClient.publish({
      headers,
      method: "POST",
      body,
      url: newUrl
    });
    return [result];
  }
};

// src/qstash/headers.ts
var WorkflowHeaders = class {
  userHeaders;
  workflowConfig;
  invokeCount;
  initHeaderValue;
  stepInfo;
  headers;
  constructor({
    userHeaders,
    workflowConfig,
    invokeCount,
    initHeaderValue,
    stepInfo
  }) {
    this.userHeaders = userHeaders;
    this.workflowConfig = workflowConfig;
    this.invokeCount = invokeCount;
    this.initHeaderValue = initHeaderValue;
    this.stepInfo = stepInfo;
    this.headers = {
      rawHeaders: {},
      workflowHeaders: {},
      failureHeaders: {}
    };
  }
  getHeaders() {
    this.addBaseHeaders();
    this.addRetries();
    this.addRetryDelay();
    this.addFlowControl();
    this.addUserHeaders();
    this.addInvokeCount();
    this.addFailureUrl();
    const contentType = this.addContentType();
    return this.prefixHeaders(contentType);
  }
  addBaseHeaders() {
    this.headers.rawHeaders = {
      ...this.headers.rawHeaders,
      [WORKFLOW_INIT_HEADER]: this.initHeaderValue,
      [WORKFLOW_ID_HEADER]: this.workflowConfig.workflowRunId,
      [WORKFLOW_URL_HEADER]: this.workflowConfig.workflowUrl,
      [WORKFLOW_FEATURE_HEADER]: "LazyFetch,InitialBody,WF_DetectTrigger",
      [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION,
      ...this.workflowConfig.telemetry ? getTelemetryHeaders(this.workflowConfig.telemetry) : {},
      ...this.workflowConfig.telemetry && this.stepInfo?.lazyStep instanceof LazyCallStep && this.stepInfo.lazyStep.headers[AGENT_NAME_HEADER] ? { [TELEMETRY_HEADER_AGENT]: "true" } : {}
    };
    if (this.stepInfo?.lazyStep.stepType !== "Call") {
      this.headers.rawHeaders[`Upstash-Forward-${WORKFLOW_PROTOCOL_VERSION_HEADER}`] = WORKFLOW_PROTOCOL_VERSION;
    }
  }
  addInvokeCount() {
    if (this.invokeCount === void 0 || this.invokeCount === 0) {
      return;
    }
    const invokeCount = this.invokeCount.toString();
    this.headers.workflowHeaders[`Forward-${WORKFLOW_INVOKE_COUNT_HEADER}`] = invokeCount;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders[`Forward-${WORKFLOW_INVOKE_COUNT_HEADER}`] = invokeCount;
    }
    if (this.stepInfo?.lazyStep instanceof LazyCallStep) {
      this.headers.rawHeaders[`Upstash-Forward-${WORKFLOW_INVOKE_COUNT_HEADER}`] = invokeCount;
    }
  }
  addRetries() {
    if (this.workflowConfig.retries === void 0 || this.workflowConfig.retries === DEFAULT_RETRIES) {
      return;
    }
    const retries = this.workflowConfig.retries.toString();
    this.headers.workflowHeaders["Retries"] = retries;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders["Retries"] = retries;
    }
  }
  addRetryDelay() {
    if (this.workflowConfig.retryDelay === void 0 || this.workflowConfig.retryDelay === "") {
      return;
    }
    const retryDelay = this.workflowConfig.retryDelay.toString();
    this.headers.workflowHeaders["Retry-Delay"] = retryDelay;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders["Retry-Delay"] = retryDelay;
    }
  }
  addFlowControl() {
    if (!this.workflowConfig.flowControl) {
      return;
    }
    const { flowControlKey, flowControlValue } = prepareFlowControl(
      this.workflowConfig.flowControl
    );
    this.headers.workflowHeaders["Flow-Control-Key"] = flowControlKey;
    this.headers.workflowHeaders["Flow-Control-Value"] = flowControlValue;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders["Flow-Control-Key"] = flowControlKey;
      this.headers.failureHeaders["Flow-Control-Value"] = flowControlValue;
    }
  }
  addUserHeaders() {
    for (const [key, value] of this.userHeaders.entries()) {
      const forwardKey = `Forward-${key}`;
      this.headers.workflowHeaders[forwardKey] = value;
      if (this.workflowConfig.failureUrl) {
        this.headers.failureHeaders[forwardKey] = value;
      }
    }
  }
  addFailureUrl() {
    if (!this.workflowConfig.failureUrl) {
      return;
    }
    this.headers.workflowHeaders["Failure-Callback"] = this.workflowConfig.failureUrl;
    this.headers.failureHeaders[`Forward-${WORKFLOW_FAILURE_HEADER}`] = "true";
    this.headers.failureHeaders[`Forward-Upstash-Workflow-Failure-Callback`] = "true";
    this.headers.failureHeaders["Workflow-Runid"] = this.workflowConfig.workflowRunId;
    this.headers.failureHeaders["Workflow-Init"] = "false";
    this.headers.failureHeaders["Workflow-Url"] = this.workflowConfig.workflowUrl;
    this.headers.failureHeaders["Workflow-Calltype"] = "failureCall";
    this.headers.failureHeaders["Feature-Set"] = "LazyFetch,InitialBody,WF_DetectTrigger";
    if (this.workflowConfig.retries !== void 0 && this.workflowConfig.retries !== DEFAULT_RETRIES) {
      this.headers.failureHeaders["Retries"] = this.workflowConfig.retries.toString();
    }
    if (this.workflowConfig.retryDelay !== void 0 && this.workflowConfig.retryDelay !== "") {
      this.headers.failureHeaders["Retry-Delay"] = this.workflowConfig.retryDelay.toString();
    }
  }
  addContentType() {
    if (this.workflowConfig.useJSONContent) {
      this.headers.rawHeaders["content-type"] = "application/json";
      return "application/json";
    }
    const callHeaders = new Headers(
      this.stepInfo?.lazyStep instanceof LazyCallStep ? this.stepInfo.lazyStep.headers : {}
    );
    const contentType = (callHeaders.get("content-type") ? callHeaders.get("content-type") : this.userHeaders?.get("Content-Type") ? this.userHeaders.get("Content-Type") : void 0) ?? DEFAULT_CONTENT_TYPE;
    this.headers.rawHeaders["content-type"] = contentType;
    return contentType;
  }
  prefixHeaders(contentType) {
    const { rawHeaders, workflowHeaders, failureHeaders } = this.headers;
    const isCall = this.stepInfo?.lazyStep.stepType === "Call";
    return {
      headers: {
        ...rawHeaders,
        ...addPrefixToHeaders(workflowHeaders, isCall ? "Upstash-Callback-" : "Upstash-"),
        ...addPrefixToHeaders(failureHeaders, "Upstash-Failure-Callback-"),
        ...isCall ? addPrefixToHeaders(failureHeaders, "Upstash-Callback-Failure-Callback-") : {}
      },
      contentType
    };
  }
};
function addPrefixToHeaders(headers, prefix) {
  const prefixedHeaders = {};
  for (const [key, value] of Object.entries(headers)) {
    prefixedHeaders[`${prefix}${key}`] = value;
  }
  return prefixedHeaders;
}
var prepareFlowControl = (flowControl) => {
  const parallelism = flowControl.parallelism?.toString();
  const rate = (flowControl.rate ?? flowControl.ratePerSecond)?.toString();
  const period = typeof flowControl.period === "number" ? `${flowControl.period}s` : flowControl.period;
  const controlValue = [
    parallelism ? `parallelism=${parallelism}` : void 0,
    rate ? `rate=${rate}` : void 0,
    period ? `period=${period}` : void 0
  ].filter(Boolean);
  if (controlValue.length === 0) {
    throw new QstashError4("Provide at least one of parallelism or ratePerSecond for flowControl");
  }
  return {
    flowControlKey: flowControl.key,
    flowControlValue: controlValue.join(", ")
  };
};
var getHeaders = (params) => {
  const workflowHeaders = new WorkflowHeaders(params);
  return workflowHeaders.getHeaders();
};

// src/qstash/submit-steps.ts
var submitParallelSteps = async ({
  context,
  steps,
  initialStepCount,
  invokeCount,
  telemetry,
  debug
}) => {
  const planSteps = steps.map(
    (step, index) => step.getPlanStep(steps.length, initialStepCount + index)
  );
  await debug?.log("SUBMIT", "SUBMIT_STEP", {
    length: planSteps.length,
    steps: planSteps
  });
  const result = await context.qstashClient.batch(
    planSteps.map((planStep) => {
      const { headers } = getHeaders({
        initHeaderValue: "false",
        workflowConfig: {
          workflowRunId: context.workflowRunId,
          workflowUrl: context.url,
          failureUrl: context.failureUrl,
          retries: context.retries,
          retryDelay: context.retryDelay,
          flowControl: context.flowControl,
          telemetry
        },
        userHeaders: context.headers,
        invokeCount
      });
      return {
        headers,
        method: "POST",
        url: context.url,
        body: JSON.stringify(planStep),
        notBefore: planStep.sleepUntil,
        delay: planStep.sleepFor
      };
    })
  );
  await debug?.log("INFO", "SUBMIT_STEP", {
    messageIds: result.map((message) => {
      return {
        message: message.messageId
      };
    })
  });
  throw new WorkflowAbort(planSteps[0].stepName, planSteps[0]);
};
var submitSingleStep = async ({
  context,
  lazyStep,
  stepId,
  invokeCount,
  concurrency,
  telemetry,
  debug
}) => {
  const resultStep = await lazyStep.getResultStep(concurrency, stepId);
  await debug?.log("INFO", "RUN_SINGLE", {
    fromRequest: false,
    step: resultStep,
    stepCount: stepId
  });
  const { headers } = lazyStep.getHeaders({
    context,
    step: resultStep,
    invokeCount,
    telemetry
  });
  const body = lazyStep.getBody({
    context,
    step: resultStep,
    headers,
    invokeCount,
    telemetry
  });
  await debug?.log("SUBMIT", "SUBMIT_STEP", {
    length: 1,
    steps: [resultStep]
  });
  const submitResult = await lazyStep.submitStep({
    context,
    body,
    headers,
    isParallel: concurrency !== NO_CONCURRENCY,
    invokeCount,
    step: resultStep,
    telemetry
  });
  await debug?.log("INFO", "SUBMIT_STEP", {
    messageIds: submitResult.map((message) => {
      return {
        message: message.messageId
      };
    })
  });
  return resultStep;
};

// src/context/auto-executor.ts
var AutoExecutor = class _AutoExecutor {
  context;
  promises = /* @__PURE__ */ new WeakMap();
  activeLazyStepList;
  debug;
  nonPlanStepCount;
  steps;
  indexInCurrentList = 0;
  invokeCount;
  telemetry;
  stepCount = 0;
  planStepCount = 0;
  executingStep = false;
  constructor(context, steps, telemetry, invokeCount, debug) {
    this.context = context;
    this.steps = steps;
    this.telemetry = telemetry;
    this.invokeCount = invokeCount ?? 0;
    this.debug = debug;
    this.nonPlanStepCount = this.steps.filter((step) => !step.targetStep).length;
  }
  /**
   * Adds the step function to the list of step functions to run in
   * parallel. After adding the function, defers the execution, so
   * that if there is another step function to be added, it's also
   * added.
   *
   * After all functions are added, list of functions are executed.
   * If there is a single function, it's executed by itself. If there
   * are multiple, they are run in parallel.
   *
   * If a function is already executing (this.executingStep), this
   * means that there is a nested step which is not allowed. In this
   * case, addStep throws WorkflowError.
   *
   * @param stepInfo step plan to add
   * @returns result of the step function
   */
  async addStep(stepInfo) {
    if (this.executingStep) {
      throw new WorkflowError(
        `A step can not be run inside another step. Tried to run '${stepInfo.stepName}' inside '${this.executingStep}'`
      );
    }
    this.stepCount += 1;
    const lazyStepList = this.activeLazyStepList ?? [];
    if (!this.activeLazyStepList) {
      this.activeLazyStepList = lazyStepList;
      this.indexInCurrentList = 0;
    }
    lazyStepList.push(stepInfo);
    const index = this.indexInCurrentList++;
    const requestComplete = this.deferExecution().then(async () => {
      if (!this.promises.has(lazyStepList)) {
        const promise2 = this.getExecutionPromise(lazyStepList);
        this.promises.set(lazyStepList, promise2);
        this.activeLazyStepList = void 0;
        this.planStepCount += lazyStepList.length > 1 ? lazyStepList.length : 0;
      }
      const promise = this.promises.get(lazyStepList);
      return promise;
    });
    const result = await requestComplete;
    return _AutoExecutor.getResult(lazyStepList, result, index);
  }
  /**
   * Wraps a step function to set this.executingStep to step name
   * before running and set this.executingStep to False after execution
   * ends.
   *
   * this.executingStep allows us to detect nested steps which are not
   * allowed.
   *
   * @param stepName name of the step being wrapped
   * @param stepFunction step function to wrap
   * @returns wrapped step function
   */
  wrapStep(stepName, stepFunction) {
    this.executingStep = stepName;
    const result = stepFunction();
    this.executingStep = false;
    return result;
  }
  /**
   * Executes a step:
   * - If the step result is available in the steps, returns the result
   * - If the result is not avaiable, runs the function
   * - Sends the result to QStash
   *
   * @param lazyStep lazy step to execute
   * @returns step result
   */
  async runSingle(lazyStep) {
    if (this.stepCount < this.nonPlanStepCount) {
      const step = this.steps[this.stepCount + this.planStepCount];
      validateStep(lazyStep, step);
      await this.debug?.log("INFO", "RUN_SINGLE", {
        fromRequest: true,
        step,
        stepCount: this.stepCount
      });
      return lazyStep.parseOut(step.out);
    }
    const resultStep = await submitSingleStep({
      context: this.context,
      lazyStep,
      stepId: this.stepCount,
      invokeCount: this.invokeCount,
      concurrency: 1,
      telemetry: this.telemetry,
      debug: this.debug
    });
    throw new WorkflowAbort(lazyStep.stepName, resultStep);
  }
  /**
   * Runs steps in parallel.
   *
   * @param stepName parallel step name
   * @param stepFunctions list of async functions to run in parallel
   * @returns results of the functions run in parallel
   */
  async runParallel(parallelSteps) {
    const initialStepCount = this.stepCount - (parallelSteps.length - 1);
    const parallelCallState = this.getParallelCallState(parallelSteps.length, initialStepCount);
    const sortedSteps = sortSteps(this.steps);
    const plannedParallelStepCount = sortedSteps[initialStepCount + this.planStepCount]?.concurrent;
    if (parallelCallState !== "first" && plannedParallelStepCount !== parallelSteps.length) {
      throw new WorkflowError(
        `Incompatible number of parallel steps when call state was '${parallelCallState}'. Expected ${parallelSteps.length}, got ${plannedParallelStepCount} from the request.`
      );
    }
    await this.debug?.log("INFO", "RUN_PARALLEL", {
      parallelCallState,
      initialStepCount,
      plannedParallelStepCount,
      stepCount: this.stepCount,
      planStepCount: this.planStepCount
    });
    switch (parallelCallState) {
      case "first": {
        await submitParallelSteps({
          context: this.context,
          steps: parallelSteps,
          initialStepCount,
          invokeCount: this.invokeCount,
          telemetry: this.telemetry,
          debug: this.debug
        });
        break;
      }
      case "partial": {
        const planStep = this.steps.at(-1);
        if (!planStep || planStep.targetStep === void 0) {
          throw new WorkflowError(
            `There must be a last step and it should have targetStep larger than 0.Received: ${JSON.stringify(planStep)}`
          );
        }
        const stepIndex = planStep.targetStep - initialStepCount;
        validateStep(parallelSteps[stepIndex], planStep);
        try {
          const parallelStep = parallelSteps[stepIndex];
          const resultStep = await submitSingleStep({
            context: this.context,
            lazyStep: parallelStep,
            stepId: planStep.targetStep,
            invokeCount: this.invokeCount,
            concurrency: parallelSteps.length,
            telemetry: this.telemetry,
            debug: this.debug
          });
          throw new WorkflowAbort(parallelStep.stepName, resultStep);
        } catch (error) {
          if (error instanceof WorkflowAbort || error instanceof QstashError5 && error.status === 400) {
            throw error;
          }
          throw new WorkflowError(
            `Error submitting steps to QStash in partial parallel step execution: ${error}`
          );
        }
        break;
      }
      case "discard": {
        throw new WorkflowAbort("discarded parallel");
      }
      case "last": {
        const parallelResultSteps = sortedSteps.filter((step) => step.stepId >= initialStepCount).slice(0, parallelSteps.length);
        validateParallelSteps(parallelSteps, parallelResultSteps);
        return parallelResultSteps.map(
          (step, index) => parallelSteps[index].parseOut(step.out)
        );
      }
    }
    const fillValue = void 0;
    return Array.from({ length: parallelSteps.length }).fill(fillValue);
  }
  /**
   * Determines the parallel call state
   *
   * First filters the steps to get the steps which are after `initialStepCount` parameter.
   *
   * Depending on the remaining steps, decides the parallel state:
   * - "first": If there are no steps
   * - "last" If there are equal to or more than `2 * parallelStepCount`. We multiply by two
   *   because each step in a parallel execution will have 2 steps: a plan step and a result
   *   step.
   * - "partial": If the last step is a plan step
   * - "discard": If the last step is not a plan step. This means that the parallel execution
   *   is in progress (there are still steps to run) and one step has finished and submitted
   *   its result to QStash
   *
   * @param parallelStepCount number of steps to run in parallel
   * @param initialStepCount steps after the parallel invocation
   * @returns parallel call state
   */
  getParallelCallState(parallelStepCount, initialStepCount) {
    const remainingSteps = this.steps.filter(
      (step) => (step.targetStep || step.stepId) >= initialStepCount
    );
    if (remainingSteps.length === 0) {
      return "first";
    } else if (remainingSteps.length >= 2 * parallelStepCount) {
      return "last";
    } else if (remainingSteps.at(-1)?.targetStep) {
      return "partial";
    } else {
      return "discard";
    }
  }
  /**
   * Get the promise by executing the lazt steps list. If there is a single
   * step, we call `runSingle`. Otherwise `runParallel` is called.
   *
   * @param lazyStepList steps list to execute
   * @returns promise corresponding to the execution
   */
  getExecutionPromise(lazyStepList) {
    return lazyStepList.length === 1 ? this.runSingle(lazyStepList[0]) : this.runParallel(lazyStepList);
  }
  /**
   * @param lazyStepList steps we executed
   * @param result result of the promise from `getExecutionPromise`
   * @param index index of the current step
   * @returns result[index] if lazyStepList > 1, otherwise result
   */
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters
  static getResult(lazyStepList, result, index) {
    if (lazyStepList.length === 1) {
      return result;
    } else if (Array.isArray(result) && lazyStepList.length === result.length && index < lazyStepList.length) {
      return result[index];
    } else {
      throw new WorkflowError(
        `Unexpected parallel call result while executing step ${index}: '${result}'. Expected ${lazyStepList.length} many items`
      );
    }
  }
  async deferExecution() {
    await Promise.resolve();
    await Promise.resolve();
  }
};
var validateStep = (lazyStep, stepFromRequest) => {
  if (lazyStep.stepName !== stepFromRequest.stepName) {
    throw new WorkflowError(
      `Incompatible step name. Expected '${lazyStep.stepName}', got '${stepFromRequest.stepName}' from the request`
    );
  }
  if (lazyStep.stepType !== stepFromRequest.stepType) {
    throw new WorkflowError(
      `Incompatible step type. Expected '${lazyStep.stepType}', got '${stepFromRequest.stepType}' from the request`
    );
  }
};
var validateParallelSteps = (lazySteps, stepsFromRequest) => {
  try {
    for (const [index, stepFromRequest] of stepsFromRequest.entries()) {
      validateStep(lazySteps[index], stepFromRequest);
    }
  } catch (error) {
    if (error instanceof WorkflowError) {
      const lazyStepNames = lazySteps.map((lazyStep) => lazyStep.stepName);
      const lazyStepTypes = lazySteps.map((lazyStep) => lazyStep.stepType);
      const requestStepNames = stepsFromRequest.map((step) => step.stepName);
      const requestStepTypes = stepsFromRequest.map((step) => step.stepType);
      throw new WorkflowError(
        `Incompatible steps detected in parallel execution: ${error.message}
  > Step Names from the request: ${JSON.stringify(requestStepNames)}
    Step Types from the request: ${JSON.stringify(requestStepTypes)}
  > Step Names expected: ${JSON.stringify(lazyStepNames)}
    Step Types expected: ${JSON.stringify(lazyStepTypes)}`
      );
    }
    throw error;
  }
};
var sortSteps = (steps) => {
  const getStepId = (step) => step.targetStep || step.stepId;
  return [...steps].sort((step, stepOther) => getStepId(step) - getStepId(stepOther));
};

// src/context/api/anthropic.ts
import { anthropic } from "@upstash/qstash";

// src/context/provider.ts
var getProviderInfo = (api) => {
  if (!api.provider) {
    throw new WorkflowError("A Provider must be provided.");
  }
  if (api.provider.owner === "upstash") {
    throw new WorkflowError("Upstash provider isn't supported.");
  }
  const { name, provider, ...parameters } = api;
  if (!provider.baseUrl) throw new TypeError("baseUrl cannot be empty or undefined!");
  if (!provider.token) throw new TypeError("token cannot be empty or undefined!");
  if (provider.apiKind !== name) {
    throw new TypeError(`Unexpected api name. Expected '${provider.apiKind}', received ${name}`);
  }
  const providerInfo = {
    url: provider.getUrl(),
    baseUrl: provider.baseUrl,
    route: provider.getRoute(),
    appendHeaders: provider.getHeaders(parameters),
    owner: provider.owner,
    method: provider.method
  };
  return provider.onFinish(providerInfo, parameters);
};

// src/context/api/base.ts
var BaseWorkflowApi = class {
  context;
  constructor({ context }) {
    this.context = context;
  }
  /**
   * context.call which uses a QStash API
   *
   * @param stepName
   * @param settings
   * @returns
   */
  async callApi(stepName, settings) {
    const { url, appendHeaders, method } = getProviderInfo(settings.api);
    const { method: userMethod, body, headers = {}, retries = 0, retryDelay, timeout } = settings;
    return await this.context.call(stepName, {
      url,
      method: userMethod ?? method,
      body,
      headers: {
        ...appendHeaders,
        ...headers
      },
      retries,
      retryDelay,
      timeout
    });
  }
};

// src/context/api/anthropic.ts
var AnthropicAPI = class extends BaseWorkflowApi {
  async call(stepName, settings) {
    const { token, operation, ...parameters } = settings;
    return await this.callApi(stepName, {
      api: {
        name: "llm",
        provider: anthropic({ token })
      },
      ...parameters
    });
  }
};

// src/context/api/openai.ts
import { custom, openai } from "@upstash/qstash";
var OpenAIAPI = class extends BaseWorkflowApi {
  async call(stepName, settings) {
    const { token, organization, operation, baseURL, ...parameters } = settings;
    const useOpenAI = baseURL === void 0;
    const provider = useOpenAI ? openai({ token, organization }) : custom({ baseUrl: baseURL, token });
    return await this.callApi(stepName, {
      api: {
        name: "llm",
        provider
      },
      ...parameters
    });
  }
};

// src/context/api/resend.ts
import { resend } from "@upstash/qstash";
var ResendAPI = class extends BaseWorkflowApi {
  async call(stepName, settings) {
    const { token, batch = false, ...parameters } = settings;
    return await this.callApi(stepName, {
      api: {
        name: "email",
        provider: resend({ token, batch })
      },
      ...parameters
    });
  }
};

// src/context/api/index.ts
var WorkflowApi = class extends BaseWorkflowApi {
  get openai() {
    return new OpenAIAPI({
      context: this.context
    });
  }
  get resend() {
    return new ResendAPI({
      context: this.context
    });
  }
  get anthropic() {
    return new AnthropicAPI({
      context: this.context
    });
  }
};

// src/agents/index.ts
import { createOpenAI } from "@ai-sdk/openai";

// src/agents/agent.ts
import { z } from "zod";
import { generateText, tool as tool2, ToolExecutionError } from "ai";

// src/serve/utils.ts
var isDisabledWorkflowContext = (context) => {
  return "disabled" in context;
};

// src/agents/agent.ts
var Agent = class {
  name;
  tools;
  maxSteps;
  background;
  model;
  temparature;
  context;
  constructor({ tools, maxSteps, background, name, model, temparature = 0.1 }, context) {
    this.name = name;
    this.tools = tools ?? {};
    this.maxSteps = maxSteps;
    this.background = background;
    this.model = model;
    this.temparature = temparature;
    this.context = context;
  }
  /**
   * Trigger the agent by passing a prompt
   *
   * @param prompt task to assign to the agent
   * @returns Response as `{ text: string }`
   */
  async call({ prompt }) {
    try {
      if (isDisabledWorkflowContext(this.context)) {
        await this.context.sleep("abort", 0);
      }
      const result = await generateText({
        model: this.model,
        tools: this.tools,
        maxSteps: this.maxSteps,
        system: this.background,
        prompt,
        headers: {
          [AGENT_NAME_HEADER]: this.name
        },
        temperature: this.temparature
      });
      return { text: result.text };
    } catch (error) {
      if (error instanceof ToolExecutionError) {
        if (error.cause instanceof Error && error.cause.name === "WorkflowAbort") {
          throw error.cause;
        } else if (error.cause instanceof ToolExecutionError && error.cause.cause instanceof Error && error.cause.cause.name === "WorkflowAbort") {
          throw error.cause.cause;
        } else {
          throw error;
        }
      } else {
        throw error;
      }
    }
  }
  /**
   * Convert the agent to a tool which can be used by other agents.
   *
   * @returns the agent as a tool
   */
  asTool() {
    const toolDescriptions = Object.values(this.tools).map((tool3) => tool3.description).join("\n");
    return tool2({
      parameters: z.object({ prompt: z.string() }),
      execute: async ({ prompt }) => {
        return await this.call({ prompt });
      },
      description: `An AI Agent with the following background: ${this.background}Has access to the following tools: ${toolDescriptions}`
    });
  }
};
var ManagerAgent = class extends Agent {
  agents;
  /**
   * A manager agent which coordinates agents available to it to achieve a
   * given task
   *
   * @param name Name of the agent
   * @param background Background of the agent. If not passed, default will be used.
   * @param model LLM model to use
   * @param agents: List of agents available to the agent
   * @param maxSteps number of times the manager agent can call the LLM at most.
   *   If the agent abruptly stops execution after calling other agents, you may
   *   need to increase maxSteps
   */
  constructor({
    agents,
    background = MANAGER_AGENT_PROMPT,
    model,
    maxSteps,
    name = "manager llm"
  }, context) {
    super(
      {
        background,
        maxSteps,
        tools: Object.fromEntries(agents.map((agent) => [agent.name, agent.asTool()])),
        name,
        model
      },
      context
    );
    this.agents = agents;
  }
};

// src/agents/task.ts
var Task = class {
  context;
  taskParameters;
  constructor({
    context,
    taskParameters
  }) {
    this.context = context;
    this.taskParameters = taskParameters;
  }
  /**
   * Run the agents to complete the task
   *
   * @returns Result of the task as { text: string }
   */
  async run() {
    const { prompt, ...otherParams } = this.taskParameters;
    if ("agent" in otherParams) {
      const agent = otherParams.agent;
      const result = await agent.call({
        prompt
      });
      return { text: result.text };
    } else {
      const { agents, maxSteps, model, background } = otherParams;
      const managerAgent = new ManagerAgent(
        {
          model,
          maxSteps,
          agents,
          name: "Manager LLM",
          background
        },
        this.context
      );
      const result = await managerAgent.call({ prompt });
      return { text: result.text };
    }
  }
};

// src/agents/index.ts
var WorkflowAgents = class {
  context;
  constructor({ context }) {
    this.context = context;
  }
  /**
   * Defines an agent
   *
   * ```ts
   * const researcherAgent = context.agents.agent({
   *   model,
   *   name: 'academic',
   *   maxSteps: 2,
   *   tools: {
   *     wikiTool: new WikipediaQueryRun({
   *       topKResults: 1,
   *       maxDocContentLength: 500,
   *     })
   *   },
   *   background:
   *     'You are researcher agent with access to Wikipedia. ' +
   *     'Utilize Wikipedia as much as possible for correct information',
   * });
   * ```
   *
   * @param params agent parameters
   * @returns
   */
  agent(params) {
    const wrappedTools = wrapTools({ context: this.context, tools: params.tools });
    return new Agent(
      {
        ...params,
        tools: wrappedTools
      },
      this.context
    );
  }
  task(taskParameters) {
    return new Task({ context: this.context, taskParameters });
  }
  /**
   * creates an openai model for agents
   */
  openai(...params) {
    const [model, settings] = params;
    const { baseURL, apiKey, callSettings, ...otherSettings } = settings ?? {};
    const openaiModel = this.AISDKModel({
      context: this.context,
      provider: createOpenAI,
      providerParams: { baseURL, apiKey, compatibility: "strict" },
      agentCallParams: callSettings
    });
    return openaiModel(model, otherSettings);
  }
  AISDKModel = createWorkflowModel;
};

// src/context/context.ts
var WorkflowContext = class {
  executor;
  steps;
  /**
   * QStash client of the workflow
   *
   * Can be overwritten by passing `qstashClient` parameter in `serve`:
   *
   * ```ts
   * import { Client } from "@upstash/qstash"
   *
   * export const POST = serve(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     qstashClient: new Client({...})
   *   }
   * )
   * ```
   */
  qstashClient;
  /**
   * Run id of the workflow
   */
  workflowRunId;
  /**
   * URL of the workflow
   *
   * Can be overwritten by passing a `url` parameter in `serve`:
   *
   * ```ts
   * export const POST = serve(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     url: "new-url-value"
   *   }
   * )
   * ```
   */
  url;
  /**
   * URL to call in case of workflow failure with QStash failure callback
   *
   * https://upstash.com/docs/qstash/features/callbacks#what-is-a-failure-callback
   *
   * Can be overwritten by passing a `failureUrl` parameter in `serve`:
   *
   * ```ts
   * export const POST = serve(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     failureUrl: "new-url-value"
   *   }
   * )
   * ```
   */
  failureUrl;
  /**
   * Payload of the request which started the workflow.
   *
   * To specify its type, you can define `serve` as follows:
   *
   * ```ts
   * // set requestPayload type to MyPayload:
   * export const POST = serve<MyPayload>(
   *   async (context) => {
   *     ...
   *   }
   * )
   * ```
   *
   * By default, `serve` tries to apply `JSON.parse` to the request payload.
   * If your payload is encoded in a format other than JSON, you can utilize
   * the `initialPayloadParser` parameter:
   *
   * ```ts
   * export const POST = serve<MyPayload>(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     initialPayloadParser: (initialPayload) => {return doSomething(initialPayload)}
   *   }
   * )
   * ```
   */
  requestPayload;
  /**
   * headers of the initial request
   */
  headers;
  /**
   * Map of environment variables and their values.
   *
   * Can be set using the `env` option of serve:
   *
   * ```ts
   * export const POST = serve<MyPayload>(
   *   async (context) => {
   *     const key = context.env["API_KEY"];
   *   },
   *   {
   *     env: {
   *       "API_KEY": "*****";
   *     }
   *   }
   * )
   * ```
   *
   * Default value is set to `process.env`.
   */
  env;
  /**
   * Number of retries
   */
  retries;
  /**
   * Delay between retries.
   *
   * By default, the `retryDelay` is exponential backoff.
   * More details can be found in: https://upstash.com/docs/qstash/features/retry.
   *
   * The `retryDelay` option allows you to customize the delay (in milliseconds) between retry attempts when message delivery fails.
   *
   * You can use mathematical expressions and the following built-in functions to calculate the delay dynamically.
   * The special variable `retried` represents the current retry attempt count (starting from 0).
   *
   * Supported functions:
   * - `pow`
   * - `sqrt`
   * - `abs`
   * - `exp`
   * - `floor`
   * - `ceil`
   * - `round`
   * - `min`
   * - `max`
   *
   * Examples of valid `retryDelay` values:
   * ```ts
   * 1000 // 1 second
   * 1000 * (1 + retried)  // 1 second multiplied by the current retry attempt
   * pow(2, retried) // 2 to the power of the current retry attempt
   * max(10, pow(2, retried)) // The greater of 10 or 2^retried
   * ```
   */
  retryDelay;
  /**
   * Settings for controlling the number of active requests
   * and number of requests per second with the same key.
   */
  flowControl;
  /**
   * Label to apply to the workflow run.
   *
   * Can be used to filter the workflow run logs.
   *
   * Can be set by passing a `label` parameter when triggering the workflow
   * with `client.trigger`:
   *
   * ```ts
   * await client.trigger({
   *   url: "https://workflow-endpoint.com",
   *   label: "my-label"
   * });
   * ```
   */
  label;
  constructor({
    qstashClient,
    workflowRunId,
    headers,
    steps,
    url,
    failureUrl,
    debug,
    initialPayload,
    env,
    retries,
    retryDelay,
    telemetry,
    invokeCount,
    flowControl,
    label
  }) {
    this.qstashClient = qstashClient;
    this.workflowRunId = workflowRunId;
    this.steps = steps;
    this.url = url;
    this.failureUrl = failureUrl;
    this.headers = headers;
    this.requestPayload = initialPayload;
    this.env = env ?? {};
    this.retries = retries ?? DEFAULT_RETRIES;
    this.retryDelay = retryDelay;
    this.flowControl = flowControl;
    this.label = label;
    this.executor = new AutoExecutor(this, this.steps, telemetry, invokeCount, debug);
  }
  /**
   * Executes a workflow step
   *
   * ```typescript
   * const result = await context.run("step 1", () => {
   *   return "result"
   * })
   * ```
   *
   * Can also be called in parallel and the steps will be executed
   * simulatenously:
   *
   * ```typescript
   * const [result1, result2] = await Promise.all([
   *   context.run("step 1", () => {
   *     return "result1"
   *   }),
   *   context.run("step 2", async () => {
   *     return await fetchResults()
   *   })
   * ])
   * ```
   *
   * @param stepName name of the step
   * @param stepFunction step function to be executed
   * @returns result of the step function
   */
  async run(stepName, stepFunction) {
    const wrappedStepFunction = () => this.executor.wrapStep(stepName, stepFunction);
    return await this.addStep(new LazyFunctionStep(stepName, wrappedStepFunction));
  }
  /**
   * Stops the execution for the duration provided.
   *
   * ```typescript
   * await context.sleep('sleep1', 3) // wait for three seconds
   * ```
   *
   * @param stepName
   * @param duration sleep duration in seconds
   * @returns undefined
   */
  async sleep(stepName, duration) {
    await this.addStep(new LazySleepStep(stepName, duration));
  }
  /**
   * Stops the execution until the date time provided.
   *
   * ```typescript
   * await context.sleepUntil('sleep1', Date.now() / 1000 + 3) // wait for three seconds
   * ```
   *
   * @param stepName
   * @param datetime time to sleep until. Can be provided as a number (in unix seconds),
   *   as a Date object or a string (passed to `new Date(datetimeString)`)
   * @returns undefined
   */
  async sleepUntil(stepName, datetime) {
    let time;
    if (typeof datetime === "number") {
      time = datetime;
    } else {
      datetime = typeof datetime === "string" ? new Date(datetime) : datetime;
      time = Math.round(datetime.getTime() / 1e3);
    }
    await this.addStep(new LazySleepUntilStep(stepName, time));
  }
  async call(stepName, settings) {
    let callStep;
    if ("workflow" in settings) {
      const url = getNewUrlFromWorkflowId(this.url, settings.workflow.workflowId);
      callStep = new LazyCallStep(
        stepName,
        url,
        "POST",
        settings.body,
        settings.headers || {},
        settings.retries || 0,
        settings.retryDelay,
        settings.timeout,
        settings.flowControl ?? settings.workflow.options.flowControl,
        settings.stringifyBody ?? true
      );
    } else {
      const {
        url,
        method = "GET",
        body,
        headers = {},
        retries = 0,
        retryDelay,
        timeout,
        flowControl,
        stringifyBody = true
      } = settings;
      callStep = new LazyCallStep(
        stepName,
        url,
        method,
        body,
        headers,
        retries,
        retryDelay,
        timeout,
        flowControl,
        stringifyBody
      );
    }
    return await this.addStep(callStep);
  }
  /**
   * Pauses workflow execution until a specific event occurs or a timeout is reached.
   *
   *```ts
   * const result = await workflow.waitForEvent("payment-confirmed", "payment.confirmed", {
   *   timeout: "5m"
   * });
   *```
   *
   * To notify a waiting workflow:
   *
   * ```ts
   * import { Client } from "@upstash/workflow";
   *
   * const client = new Client({ token: "<QSTASH_TOKEN>" });
   *
   * await client.notify({
   *   eventId: "payment.confirmed",
   *   data: {
   *     amount: 99.99,
   *     currency: "USD"
   *   }
   * })
   * ```
   *
   * Alternatively, you can use the `context.notify` method.
   *
   * @param stepName
   * @param eventId - Unique identifier for the event to wait for
   * @param options - Configuration options.
   * @returns `{ timeout: boolean, eventData: TEventData }`.
   *   The `timeout` property specifies if the workflow has timed out. The `eventData`
   *   is the data passed when notifying this workflow of an event.
   */
  async waitForEvent(stepName, eventId, options = {}) {
    const { timeout = "7d" } = options;
    const timeoutStr = typeof timeout === "string" ? timeout : `${timeout}s`;
    return await this.addStep(new LazyWaitForEventStep(stepName, eventId, timeoutStr));
  }
  /**
   * Notify workflow runs waiting for an event
   *
   * ```ts
   * const { eventId, eventData, notifyResponse } = await context.notify(
   *   "notify step", "event-id", "event-data"
   * );
   * ```
   *
   * Upon `context.notify`, the workflow runs waiting for the given eventId (context.waitForEvent)
   * will receive the given event data and resume execution.
   *
   * The response includes the same eventId and eventData. Additionally, there is
   * a notifyResponse field which contains a list of `Waiter` objects, each corresponding
   * to a notified workflow run.
   *
   * @param stepName
   * @param eventId event id to notify
   * @param eventData event data to notify with
   * @returns notify response which has event id, event data and list of waiters which were notified
   */
  async notify(stepName, eventId, eventData) {
    return await this.addStep(
      new LazyNotifyStep(stepName, eventId, eventData, this.qstashClient.http)
    );
  }
  async invoke(stepName, settings) {
    return await this.addStep(new LazyInvokeStep(stepName, settings));
  }
  /**
   * Cancel the current workflow run
   *
   * Will throw WorkflowAbort to stop workflow execution.
   * Shouldn't be inside try/catch.
   */
  async cancel() {
    throw new WorkflowAbort("cancel", void 0, true);
  }
  /**
   * Adds steps to the executor. Needed so that it can be overwritten in
   * DisabledWorkflowContext.
   */
  async addStep(step) {
    return await this.executor.addStep(step);
  }
  get api() {
    return new WorkflowApi({
      context: this
    });
  }
  get agents() {
    return new WorkflowAgents({
      context: this
    });
  }
};

// src/logger.ts
var LOG_LEVELS = ["DEBUG", "INFO", "SUBMIT", "WARN", "ERROR"];
var WorkflowLogger = class _WorkflowLogger {
  logs = [];
  options;
  workflowRunId = void 0;
  constructor(options) {
    this.options = options;
  }
  async log(level, eventType, details) {
    if (this.shouldLog(level)) {
      const timestamp = Date.now();
      const logEntry = {
        timestamp,
        workflowRunId: this.workflowRunId ?? "",
        logLevel: level,
        eventType,
        details
      };
      this.logs.push(logEntry);
      if (this.options.logOutput === "console") {
        this.writeToConsole(logEntry);
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  setWorkflowRunId(workflowRunId) {
    this.workflowRunId = workflowRunId;
  }
  writeToConsole(logEntry) {
    const JSON_SPACING = 2;
    const logMethod = logEntry.logLevel === "ERROR" ? console.error : logEntry.logLevel === "WARN" ? console.warn : console.log;
    logMethod(JSON.stringify(logEntry, void 0, JSON_SPACING));
  }
  shouldLog(level) {
    return LOG_LEVELS.indexOf(level) >= LOG_LEVELS.indexOf(this.options.logLevel);
  }
  static getLogger(verbose) {
    if (typeof verbose === "object") {
      return verbose;
    } else {
      return verbose ? new _WorkflowLogger({
        logLevel: "INFO",
        logOutput: "console"
      }) : void 0;
    }
  }
};

// src/serve/authorization.ts
import { Client as Client2 } from "@upstash/qstash";
var DisabledWorkflowContext = class _DisabledWorkflowContext extends WorkflowContext {
  static disabledMessage = "disabled-qstash-worklfow-run";
  disabled = true;
  /**
   * overwrite the WorkflowContext.addStep method to always raise WorkflowAbort
   * error in order to stop the execution whenever we encounter a step.
   *
   * @param _step
   */
  async addStep(_step) {
    throw new WorkflowAbort(_DisabledWorkflowContext.disabledMessage);
  }
  /**
   * overwrite cancel method to throw WorkflowAbort with the disabledMessage
   */
  async cancel() {
    throw new WorkflowAbort(_DisabledWorkflowContext.disabledMessage);
  }
  /**
   * copies the passed context to create a DisabledWorkflowContext. Then, runs the
   * route function with the new context.
   *
   * - returns "run-ended" if there are no steps found or
   *      if the auth failed and user called `return`
   * - returns "step-found" if DisabledWorkflowContext.addStep is called.
   * - if there is another error, returns the error.
   *
   * @param routeFunction
   */
  static async tryAuthentication(routeFunction, context) {
    const disabledContext = new _DisabledWorkflowContext({
      qstashClient: new Client2({
        baseUrl: "disabled-client",
        token: "disabled-client"
      }),
      workflowRunId: context.workflowRunId,
      headers: context.headers,
      steps: [],
      url: context.url,
      failureUrl: context.failureUrl,
      initialPayload: context.requestPayload,
      env: context.env,
      retries: context.retries,
      retryDelay: context.retryDelay,
      flowControl: context.flowControl,
      label: context.label
    });
    try {
      await routeFunction(disabledContext);
    } catch (error) {
      if (error instanceof WorkflowAbort && error.stepName === this.disabledMessage || error instanceof WorkflowNonRetryableError) {
        return ok("step-found");
      }
      console.warn(
        "Upstash Workflow: Received an error while authorizing request. Please avoid throwing errors before the first step of your workflow."
      );
      return err(error);
    }
    return ok("run-ended");
  }
};

// src/workflow-parser.ts
var getPayload = async (request) => {
  try {
    return await request.text();
  } catch {
    return;
  }
};
var processRawSteps = (rawSteps) => {
  const [encodedInitialPayload, ...encodedSteps] = rawSteps;
  const rawInitialPayload = decodeBase64(encodedInitialPayload.body);
  const initialStep = {
    stepId: 0,
    stepName: "init",
    stepType: "Initial",
    out: rawInitialPayload,
    concurrent: NO_CONCURRENCY
  };
  const stepsToDecode = encodedSteps.filter((step) => step.callType === "step");
  const otherSteps = stepsToDecode.map((rawStep) => {
    const step = JSON.parse(decodeBase64(rawStep.body));
    if (step.waitEventId) {
      const newOut = {
        eventData: step.out ? decodeBase64(step.out) : void 0,
        timeout: step.waitTimeout ?? false
      };
      step.out = newOut;
    }
    return step;
  });
  const steps = [initialStep, ...otherSteps];
  return {
    rawInitialPayload,
    steps
  };
};
var deduplicateSteps = (steps) => {
  const targetStepIds = [];
  const stepIds = [];
  const deduplicatedSteps = [];
  for (const step of steps) {
    if (step.stepId === 0) {
      if (!targetStepIds.includes(step.targetStep ?? 0)) {
        deduplicatedSteps.push(step);
        targetStepIds.push(step.targetStep ?? 0);
      }
    } else {
      if (!stepIds.includes(step.stepId)) {
        deduplicatedSteps.push(step);
        stepIds.push(step.stepId);
      }
    }
  }
  return deduplicatedSteps;
};
var checkIfLastOneIsDuplicate = async (steps, debug) => {
  if (steps.length < 2) {
    return false;
  }
  const lastStep = steps.at(-1);
  const lastStepId = lastStep.stepId;
  const lastTargetStepId = lastStep.targetStep;
  for (let index = 0; index < steps.length - 1; index++) {
    const step = steps[index];
    if (step.stepId === lastStepId && step.targetStep === lastTargetStepId) {
      const message = `Upstash Workflow: The step '${step.stepName}' with id '${step.stepId}'  has run twice during workflow execution. Rest of the workflow will continue running as usual.`;
      await debug?.log("WARN", "RESPONSE_DEFAULT", message);
      console.warn(message);
      return true;
    }
  }
  return false;
};
var validateRequest = (request) => {
  const versionHeader = request.headers.get(WORKFLOW_PROTOCOL_VERSION_HEADER);
  const isFirstInvocation = !versionHeader;
  if (!isFirstInvocation && versionHeader !== WORKFLOW_PROTOCOL_VERSION) {
    throw new WorkflowError(
      `Incompatible workflow sdk protocol version. Expected ${WORKFLOW_PROTOCOL_VERSION}, got ${versionHeader} from the request.`
    );
  }
  const workflowRunId = isFirstInvocation ? getWorkflowRunId() : request.headers.get(WORKFLOW_ID_HEADER) ?? "";
  if (workflowRunId.length === 0) {
    throw new WorkflowError("Couldn't get workflow id from header");
  }
  return {
    isFirstInvocation,
    workflowRunId
  };
};
var parseRequest = async (requestPayload, isFirstInvocation, workflowRunId, requester, messageId, debug) => {
  if (isFirstInvocation) {
    return {
      rawInitialPayload: requestPayload ?? "",
      steps: [],
      isLastDuplicate: false,
      workflowRunEnded: false
    };
  } else {
    let rawSteps;
    if (!requestPayload) {
      await debug?.log(
        "INFO",
        "ENDPOINT_START",
        "request payload is empty, steps will be fetched from QStash."
      );
      const { steps: fetchedSteps, workflowRunEnded } = await getSteps(
        requester,
        workflowRunId,
        messageId,
        debug
      );
      if (workflowRunEnded) {
        return {
          rawInitialPayload: void 0,
          steps: void 0,
          isLastDuplicate: void 0,
          workflowRunEnded: true
        };
      }
      rawSteps = fetchedSteps;
    } else {
      rawSteps = JSON.parse(requestPayload);
    }
    const { rawInitialPayload, steps } = processRawSteps(rawSteps);
    const isLastDuplicate = await checkIfLastOneIsDuplicate(steps, debug);
    const deduplicatedSteps = deduplicateSteps(steps);
    return {
      rawInitialPayload,
      steps: deduplicatedSteps,
      isLastDuplicate,
      workflowRunEnded: false
    };
  }
};
var handleFailure = async (request, requestPayload, qstashClient, initialPayloadParser, routeFunction, failureFunction, env, retries, retryDelay, flowControl, debug) => {
  if (request.headers.get(WORKFLOW_FAILURE_HEADER) !== "true") {
    return ok({ result: "not-failure-callback" });
  }
  if (!failureFunction) {
    return err(
      new WorkflowError(
        "Workflow endpoint is called to handle a failure, but a failureFunction is not provided in serve options. Either provide a failureUrl or a failureFunction."
      )
    );
  }
  try {
    const { status, header, body, url, sourceBody, workflowRunId } = JSON.parse(requestPayload);
    const decodedBody = body ? decodeBase64(body) : "{}";
    let errorMessage = "";
    let failStack = "";
    try {
      const errorPayload = JSON.parse(decodedBody);
      if (errorPayload.message) {
        errorMessage = errorPayload.message;
      }
      if (errorPayload.stack) {
        failStack = errorPayload.stack;
      }
    } catch {
    }
    if (!errorMessage) {
      errorMessage = `Couldn't parse 'failResponse' in 'failureFunction', received: '${decodedBody}'`;
    }
    const userHeaders = recreateUserHeaders(request.headers);
    const workflowContext = new WorkflowContext({
      qstashClient,
      workflowRunId,
      initialPayload: sourceBody ? initialPayloadParser(decodeBase64(sourceBody)) : void 0,
      headers: userHeaders,
      steps: [],
      url,
      failureUrl: url,
      debug,
      env,
      retries,
      retryDelay,
      flowControl,
      telemetry: void 0,
      // not going to make requests in authentication check
      label: userHeaders.get(WORKFLOW_LABEL_HEADER) ?? void 0
    });
    const authCheck = await DisabledWorkflowContext.tryAuthentication(
      routeFunction,
      workflowContext
    );
    if (authCheck.isErr()) {
      await debug?.log("ERROR", "ERROR", { error: authCheck.error.message });
      throw authCheck.error;
    } else if (authCheck.value === "run-ended") {
      return err(new WorkflowError("Not authorized to run the failure function."));
    }
    const failureResponse = await failureFunction({
      context: workflowContext,
      failStatus: status,
      failResponse: errorMessage,
      failHeaders: header,
      failStack
    });
    return ok({ result: "is-failure-callback", response: failureResponse });
  } catch (error) {
    return err(error);
  }
};

// src/serve/options.ts
import { Receiver } from "@upstash/qstash";
import { Client as Client3 } from "@upstash/qstash";
var processOptions = (options) => {
  const environment = options?.env ?? (typeof process === "undefined" ? {} : process.env);
  const receiverEnvironmentVariablesSet = Boolean(
    environment.QSTASH_CURRENT_SIGNING_KEY && environment.QSTASH_NEXT_SIGNING_KEY
  );
  return {
    qstashClient: options?.qstashClient ?? new Client3({
      baseUrl: environment.QSTASH_URL,
      token: environment.QSTASH_TOKEN
    }),
    onStepFinish: (workflowRunId, _finishCondition, detailedFinishCondition) => {
      if (detailedFinishCondition?.condition === "auth-fail") {
        console.error(AUTH_FAIL_MESSAGE);
        return new Response(
          JSON.stringify({
            message: AUTH_FAIL_MESSAGE,
            workflowRunId
          }),
          {
            status: 400,
            headers: {
              [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
            }
          }
        );
      } else if (detailedFinishCondition?.condition === "non-retryable-error") {
        return new Response(JSON.stringify(formatWorkflowError(detailedFinishCondition.result)), {
          headers: {
            "Upstash-NonRetryable-Error": "true",
            [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
          },
          status: 489
        });
      } else if (detailedFinishCondition?.condition === "failure-callback") {
        return new Response(detailedFinishCondition.result ?? void 0, {
          status: 200,
          headers: {
            [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
          }
        });
      }
      return new Response(JSON.stringify({ workflowRunId }), {
        status: 200,
        headers: {
          [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
        }
      });
    },
    initialPayloadParser: (initialRequest) => {
      if (!initialRequest) {
        return void 0;
      }
      try {
        const parsed = JSON.parse(initialRequest);
        return options?.schema ? options.schema.parse(parsed) : parsed;
      } catch (error) {
        if (error instanceof SyntaxError) {
          return initialRequest;
        }
        throw error;
      }
    },
    receiver: receiverEnvironmentVariablesSet ? new Receiver({
      currentSigningKey: environment.QSTASH_CURRENT_SIGNING_KEY,
      nextSigningKey: environment.QSTASH_NEXT_SIGNING_KEY
    }) : void 0,
    baseUrl: environment.UPSTASH_WORKFLOW_URL,
    env: environment,
    retries: DEFAULT_RETRIES,
    useJSONContent: false,
    disableTelemetry: false,
    onError: console.error,
    ...options
  };
};
var determineUrls = async (request, url, baseUrl, failureFunction, failureUrl, debug) => {
  const initialWorkflowUrl = url ?? request.url;
  const workflowUrl = baseUrl ? initialWorkflowUrl.replace(/^(https?:\/\/[^/]+)(\/.*)?$/, (_, matchedBaseUrl, path) => {
    return baseUrl + (path || "");
  }) : initialWorkflowUrl;
  if (workflowUrl !== initialWorkflowUrl) {
    await debug?.log("WARN", "ENDPOINT_START", {
      warning: `Upstash Workflow: replacing the base of the url with "${baseUrl}" and using it as workflow endpoint.`,
      originalURL: initialWorkflowUrl,
      updatedURL: workflowUrl
    });
  }
  const workflowFailureUrl = failureFunction ? workflowUrl : failureUrl;
  if (workflowUrl.includes("localhost")) {
    await debug?.log("WARN", "ENDPOINT_START", {
      message: `Workflow URL contains localhost. This can happen in local development, but shouldn't happen in production unless you have a route which contains localhost. Received: ${workflowUrl}`
    });
  }
  if (!(workflowUrl.startsWith("http://") || workflowUrl.startsWith("https://"))) {
    throw new WorkflowError(
      `Workflow URL should start with 'http://' or 'https://'. Recevied is '${workflowUrl}'`
    );
  }
  return {
    workflowUrl,
    workflowFailureUrl
  };
};
var AUTH_FAIL_MESSAGE = `Failed to authenticate Workflow request. If this is unexpected, see the caveat https://upstash.com/docs/workflow/basics/caveats#avoid-non-deterministic-code-outside-context-run`;

// src/serve/index.ts
var serveBase = (routeFunction, telemetry, options) => {
  const {
    qstashClient,
    onStepFinish,
    initialPayloadParser,
    url,
    verbose,
    receiver,
    failureUrl,
    failureFunction,
    baseUrl,
    env,
    retries,
    retryDelay,
    useJSONContent,
    disableTelemetry,
    flowControl,
    onError
  } = processOptions(options);
  telemetry = disableTelemetry ? void 0 : telemetry;
  const debug = WorkflowLogger.getLogger(verbose);
  const handler = async (request) => {
    await debug?.log("INFO", "ENDPOINT_START");
    const { workflowUrl, workflowFailureUrl } = await determineUrls(
      request,
      url,
      baseUrl,
      failureFunction,
      failureUrl,
      debug
    );
    const requestPayload = await getPayload(request) ?? "";
    await verifyRequest(requestPayload, request.headers.get("upstash-signature"), receiver);
    const { isFirstInvocation, workflowRunId } = validateRequest(request);
    debug?.setWorkflowRunId(workflowRunId);
    const { rawInitialPayload, steps, isLastDuplicate, workflowRunEnded } = await parseRequest(
      requestPayload,
      isFirstInvocation,
      workflowRunId,
      qstashClient.http,
      request.headers.get("upstash-message-id"),
      debug
    );
    if (workflowRunEnded) {
      return onStepFinish(workflowRunId, "workflow-already-ended", {
        condition: "workflow-already-ended"
      });
    }
    if (isLastDuplicate) {
      return onStepFinish(workflowRunId, "duplicate-step", {
        condition: "duplicate-step"
      });
    }
    const failureCheck = await handleFailure(
      request,
      requestPayload,
      qstashClient,
      initialPayloadParser,
      routeFunction,
      failureFunction,
      env,
      retries,
      retryDelay,
      flowControl,
      debug
    );
    if (failureCheck.isErr()) {
      throw failureCheck.error;
    } else if (failureCheck.value.result === "is-failure-callback") {
      await debug?.log("WARN", "RESPONSE_DEFAULT", "failureFunction executed");
      return onStepFinish(workflowRunId, "failure-callback", {
        condition: "failure-callback",
        result: failureCheck.value.response
      });
    }
    const invokeCount = Number(request.headers.get(WORKFLOW_INVOKE_COUNT_HEADER) ?? "0");
    const label = request.headers.get(WORKFLOW_LABEL_HEADER) ?? void 0;
    const workflowContext = new WorkflowContext({
      qstashClient,
      workflowRunId,
      initialPayload: initialPayloadParser(rawInitialPayload),
      headers: recreateUserHeaders(request.headers),
      steps,
      url: workflowUrl,
      failureUrl: workflowFailureUrl,
      debug,
      env,
      retries,
      retryDelay,
      telemetry,
      invokeCount,
      flowControl,
      label
    });
    const authCheck = await DisabledWorkflowContext.tryAuthentication(
      routeFunction,
      workflowContext
    );
    if (authCheck.isErr()) {
      await debug?.log("ERROR", "ERROR", { error: authCheck.error.message });
      throw authCheck.error;
    } else if (authCheck.value === "run-ended") {
      await debug?.log("ERROR", "ERROR", { error: AUTH_FAIL_MESSAGE });
      return onStepFinish(
        isFirstInvocation ? "no-workflow-id" : workflowContext.workflowRunId,
        "auth-fail",
        { condition: "auth-fail" }
      );
    }
    const callReturnCheck = await handleThirdPartyCallResult({
      request,
      requestPayload: rawInitialPayload,
      client: qstashClient,
      workflowUrl,
      failureUrl: workflowFailureUrl,
      retries,
      retryDelay,
      flowControl,
      telemetry,
      debug
    });
    if (callReturnCheck.isErr()) {
      await debug?.log("ERROR", "SUBMIT_THIRD_PARTY_RESULT", {
        error: callReturnCheck.error.message
      });
      throw callReturnCheck.error;
    } else if (callReturnCheck.value === "continue-workflow") {
      const result = isFirstInvocation ? await triggerFirstInvocation({
        workflowContext,
        useJSONContent,
        telemetry,
        debug,
        invokeCount
      }) : await triggerRouteFunction({
        onStep: async () => routeFunction(workflowContext),
        onCleanup: async (result2) => {
          await triggerWorkflowDelete(workflowContext, result2, debug);
        },
        onCancel: async () => {
          await makeCancelRequest(workflowContext.qstashClient.http, workflowRunId);
        },
        debug
      });
      if (result.isOk() && result.value instanceof WorkflowNonRetryableError) {
        return onStepFinish(workflowRunId, result.value, {
          condition: "non-retryable-error",
          result: result.value
        });
      }
      if (result.isErr()) {
        await debug?.log("ERROR", "ERROR", { error: result.error.message });
        throw result.error;
      }
      await debug?.log("INFO", "RESPONSE_WORKFLOW");
      return onStepFinish(workflowContext.workflowRunId, "success", {
        condition: "success"
      });
    } else if (callReturnCheck.value === "workflow-ended") {
      return onStepFinish(workflowContext.workflowRunId, "workflow-already-ended", {
        condition: "workflow-already-ended"
      });
    }
    await debug?.log("INFO", "RESPONSE_DEFAULT");
    return onStepFinish("no-workflow-id", "fromCallback", {
      condition: "fromCallback"
    });
  };
  const safeHandler = async (request) => {
    try {
      return await handler(request);
    } catch (error) {
      const formattedError = formatWorkflowError(error);
      try {
        onError?.(error);
      } catch (onErrorError) {
        const formattedOnErrorError = formatWorkflowError(onErrorError);
        const errorMessage = `Error while running onError callback: '${formattedOnErrorError.message}'.
Original error: '${formattedError.message}'`;
        console.error(errorMessage);
        return new Response(errorMessage, {
          status: 500,
          headers: {
            [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
          }
        });
      }
      return new Response(JSON.stringify(formattedError), {
        status: 500,
        headers: {
          [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
        }
      });
    }
  };
  return { handler: safeHandler };
};
var serve = (routeFunction, options) => {
  return serveBase(
    routeFunction,
    {
      sdk: SDK_TELEMETRY,
      framework: "unknown"
    },
    options
  );
};

export {
  __require,
  __commonJS,
  __toESM,
  makeNotifyRequest,
  makeGetWaitersRequest,
  WORKFLOW_LABEL_HEADER,
  SDK_TELEMETRY,
  WorkflowError,
  WorkflowAbort,
  WorkflowNonRetryableError,
  getWorkflowRunId,
  StepTypes,
  triggerFirstInvocation,
  prepareFlowControl,
  WorkflowTool,
  serveManyBase,
  WorkflowContext,
  WorkflowLogger,
  serveBase,
  serve
};
